<html>
<head>
<script type="text/javascript" charset="utf-8">
  var tabQueue = []; // Queue of tabs to restore with scroll info
  var keyQueue = ""; // Queue of keys typed

  // Port handler mapping
  var portHandlers = { "keyDown":              handleKeyDown,
                       "returnScrollPosition": handleReturnScrollPosition };

  // Event handlers
  var selectionChangedHandlers = [];
  var getScrollPositionHandlers = {}; // tabId -> function (tab, scrollTop, scrollLeft)
  var tabLoadedHandlers = {}; // tabId -> function ()

  chrome.extension.onConnect.addListener(function(port, name) {
    if (portHandlers[port.name])
    {
      port.onMessage.addListener(portHandlers[port.name]);
    }
  });

  function handleReturnScrollPosition(args) {
    if (getScrollPositionHandlers[args.currentTab.id])
    {
      // Delete first to be sure there's no circular events.
      var toCall = getScrollPositionHandlers[args.currentTab.id];
      delete getScrollPositionHandlers[args.currentTab.id];
      toCall(args.currentTab, args.scrollTop, args.scrollLeft);
    }
  }

  chrome.tabs.onUpdated.addListener(function (tabId, changeInfo) {
    if (changeInfo.status == "complete" && tabLoadedHandlers[tabId])
    {
      // Delete first to be sure there's no circular events.
      var toCall = tabLoadedHandlers[tabId];
      delete tabLoadedHandlers[tabId];
      toCall.call();
    }
  });

  chrome.tabs.onSelectionChanged.addListener(function (tabId, selectionInfo) {
    if (selectionChangedHandlers.length > 0) { selectionChangedHandlers.pop().call(); }
  });

  function repeatFunction(func, totalCount, currentCount) {
    if (currentCount < totalCount)
    {
      func(function () { repeatFunction(func, totalCount, currentCount + 1); });
    }
  }

  // Returns the currently selected tab along with scroll coordinates. Pass in a callback of the form:
  //   function (tab, scrollTop, scrollLeft) { .. }
  function getCurrentTabWithScrollPosition(callback) {
    chrome.tabs.getSelected(null, function (tab) {
      getScrollPositionHandlers[tab.id] = callback;
      var scrollPort = chrome.tabs.connect(tab.id, {name: "getScrollPosition"});
      scrollPort.postMessage({currentTab: tab});
    });
  }

  // Start action functions
  function createTab(callback) {
    chrome.tabs.create({}, function (tab) { callback(); });
  }

  function removeTab(callback) {
    getCurrentTabWithScrollPosition(function(tab, scrollTop, scrollLeft) {
                                      tabQueue.push({ tabUrl: tab.url, scrollTop: scrollTop,
                                                      scrollLeft: scrollLeft });
                                      chrome.tabs.remove(tab.id);
                                      // We can't just call the callback here because we actually need to wait
                                      // for the selection to change to consider this action done.
                                      selectionChangedHandlers.push(callback);
                                    });
  }

  function restoreTab(callback) {
    if (tabQueue.length > 0) {
      var tabQueueEntry = tabQueue.pop();

      // We have to chain a few callbacks to set the appropriate scroll position. We can't just wait until the
      // tab is created because the content script is not available during the "loading" state. We need to
      // wait until that's over before we can call setScrollPosition.
      chrome.tabs.create({ url: tabQueueEntry.tabUrl }, function (tab) {
        tabLoadedHandlers[tab.id] = function () {
          var scrollPort = chrome.tabs.connect(tab.id, {name: "setScrollPosition"});
          scrollPort.postMessage({ scrollTop: tabQueueEntry.scrollTop, scrollLeft: tabQueueEntry.scrollLeft });
        };

        callback();
      });
    }
  }
  // End action functions

  var keyToCommandRegistry = {};
  keyToCommandRegistry['j']  = 'scrollDown';
  keyToCommandRegistry['k']  = 'scrollUp';
  keyToCommandRegistry['h']  = 'scrollLeft';
  keyToCommandRegistry['l']  = 'scrollRight';
  keyToCommandRegistry['gg'] = 'scrollToTop';
  keyToCommandRegistry['G']  = 'scrollToBottom';
  keyToCommandRegistry['r']  = 'reload';
  keyToCommandRegistry['t']  = createTab;
  keyToCommandRegistry['d']  = removeTab;
  keyToCommandRegistry['u']  = restoreTab;

  function handleKeyDown(key) {
    keyQueue = keyQueue + key;
    console.log("current keyQueue: [", keyQueue, "]");
    checkKeyQueue();
  }

  function checkKeyQueue() {
    var match = /([0-9]*)(.*)/.exec(keyQueue);
    var count = parseInt(match[1]);
    var command = match[2];

    if (command.length == 0) { return; }
    if (isNaN(count)) { count = 1; }

    if (keyToCommandRegistry[command])
    {
      registryEntry = keyToCommandRegistry[command];
      console.log("command found for [", keyQueue, "],", registryEntry);

      if (typeof(registryEntry) == "string")
      {
        chrome.tabs.getSelected(null, function (tab) {
          var port = chrome.tabs.connect(tab.id, {name: "executePageCommand"});
          port.postMessage({command: registryEntry, count: count});
        });
      }
      else { repeatFunction(registryEntry, count, 0); }
      
      keyQueue = "";
    }
    else if (command.length > 1)
      keyQueue = "";
  }
</script>

</head>

<body>
  howdy
</body>

</html>
