<html>
<head>
<script type="text/javascript" charset="utf-8">
  var tabQueue = []; // Queue of tabs to restore with scroll info
  var keyQueue = ""; // Queue of keys typed

  // Port handler mapping
  var portHandlers = { "keyDown":              handleKeyDown,
                       "returnScrollPosition": handleReturnScrollPosition };

  // Event handlers
  var selectionChangedHandlers = [];
  var getScrollPositionHandlers = {}; // tabId -> function (tab, scrollX, scrollY);
  var tabLoadedHandlers = {}; // tabId -> function ()

  chrome.extension.onConnect.addListener(function(port, name) {
    var senderTabId = port.sender.tab ? port.sender.tab.id : null;
    // If this is a tab we've been waiting to open, execute any "tab loaded" handlers, e.g. to restore
    // the tab's scroll position.
    if (senderTabId && tabLoadedHandlers[senderTabId]) {
      var toCall = tabLoadedHandlers[senderTabId];
      // Delete first to be sure there's no circular events.
      delete tabLoadedHandlers[senderTabId];
      toCall.call();
    }

    if (portHandlers[port.name])
      port.onMessage.addListener(portHandlers[port.name]);

  });

  function handleReturnScrollPosition(args) {
    if (getScrollPositionHandlers[args.currentTab.id])
    {
      // Delete first to be sure there's no circular events.
      var toCall = getScrollPositionHandlers[args.currentTab.id];
      delete getScrollPositionHandlers[args.currentTab.id];
      toCall(args.currentTab, args.scrollX, args.scrollY);
    }
  }

  chrome.tabs.onSelectionChanged.addListener(function (tabId, selectionInfo) {
    if (selectionChangedHandlers.length > 0) { selectionChangedHandlers.pop().call(); }
  });

  function repeatFunction(func, totalCount, currentCount) {
    if (currentCount < totalCount)
    {
      func(function () { repeatFunction(func, totalCount, currentCount + 1); });
    }
  }

  // Returns the currently selected tab along with scroll coordinates. Pass in a callback of the form:
  //   function (tab, scrollX, scrollY) { .. }
  function getCurrentTabWithScrollPosition(callback) {
    chrome.tabs.getSelected(null, function (tab) {
      getScrollPositionHandlers[tab.id] = callback;
      var scrollPort = chrome.tabs.connect(tab.id, {name: "getScrollPosition"});
      scrollPort.postMessage({currentTab: tab});
    });
  }

  // Start action functions
  function createTab(callback) {
    chrome.tabs.create({}, function (tab) { callback(); });
  }

  function removeTab(callback) {
    getCurrentTabWithScrollPosition(function(tab, scrollX, scrollY) {
                                      tabQueue.push({ tabUrl: tab.url, scrollX: scrollX, scrollY: scrollY });
                                      chrome.tabs.remove(tab.id);
                                      // We can't just call the callback here because we actually need to wait
                                      // for the selection to change to consider this action done.
                                      selectionChangedHandlers.push(callback);
                                    });
  }

  function restoreTab(callback) {
    if (tabQueue.length > 0) {
      var tabQueueEntry = tabQueue.pop();

      // We have to chain a few callbacks to set the appropriate scroll position. We can't just wait until the
      // tab is created because the content script is not available during the "loading" state. We need to
      // wait until that's over before we can call setScrollPosition.
      chrome.tabs.create({ url: tabQueueEntry.tabUrl }, function (tab) {
        tabLoadedHandlers[tab.id] = function () {
          var scrollPort = chrome.tabs.connect(tab.id, {name: "setScrollPosition"});
          scrollPort.postMessage({ scrollX: tabQueueEntry.scrollX, scrollY: tabQueueEntry.scrollY });
        };

        callback();
      });
    }
  }
  // End action functions

  var keyToCommandRegistry = {};
  keyToCommandRegistry['j']  = 'scrollDown';
  keyToCommandRegistry['k']  = 'scrollUp';
  keyToCommandRegistry['h']  = 'scrollLeft';
  keyToCommandRegistry['l']  = 'scrollRight';
  keyToCommandRegistry['gg'] = 'scrollToTop';
  keyToCommandRegistry['G']  = 'scrollToBottom';
  keyToCommandRegistry['r']  = 'reload';

  keyToCommandRegistry['ba'] = 'goBack';
  keyToCommandRegistry['H']  = 'goBack';
  keyToCommandRegistry['fw'] = 'goForward';
  keyToCommandRegistry['fo'] = 'goForward';
  keyToCommandRegistry['L']  = 'goForward';

  keyToCommandRegistry['t']  = createTab;
  keyToCommandRegistry['d']  = removeTab;
  keyToCommandRegistry['u']  = restoreTab;

  function handleKeyDown(key) {
    keyQueue = keyQueue + key;
    console.log("current keyQueue: [", keyQueue, "]");
    checkKeyQueue();
  }

  function checkKeyQueue() {
    var match = /([0-9]*)(.*)/.exec(keyQueue);
    var count = parseInt(match[1]);
    var command = match[2];

    if (command.length == 0) { return; }
    if (isNaN(count)) { count = 1; }

    if (keyToCommandRegistry[command])
    {
      registryEntry = keyToCommandRegistry[command];
      console.log("command found for [", keyQueue, "],", registryEntry);

      if (typeof(registryEntry) == "string")
      {
        chrome.tabs.getSelected(null, function (tab) {
          var port = chrome.tabs.connect(tab.id, {name: "executePageCommand"});
          port.postMessage({command: registryEntry, count: count});
        });
      }
      else { repeatFunction(registryEntry, count, 0); }

      keyQueue = "";
    }
    else if (command.length > 1)
      keyQueue = "";
  }
</script>

</head>

<body>
  howdy
</body>

</html>
